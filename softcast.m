clcclear all  vidio = VideoReader('test.mp4');frame_num = vidio.NumFrames;I = [];for ii = 1:40    I = cat(3,I,rgb2gray(read(vidio,ii)));end [height, width, frame_num] = size(I);test_I = I(1:512,1:512,11:14);[height, width, frame_num] = size(test_I);                          %时间分辨率(时间间隔），抽样时间间隔bh = height/64;bw = width/64;block_num = 0;imshow(test_I(:,:,1));double(test_I);figure; X_dct = dct3(test_I);bitmap = zeros(bh,bw,frame_num);X = [];%% 舍弃块 块大小64*64*1 for ff = 1:frame_num    for ii = 1:bh         for jj = 1:bw            b = X_dct(1+(ii-1)*64:ii*64,1+(jj-1)*64:jj*64,ff);            if (sum(b(:)==0)<=64) %阈值随信道环境改变                bitmap(ii,jj,ff) = 1;                block_num = block_num + 1;                X = cat(1,X,reshape(b,1,64*64));            end        end    endend[X_h,X_w] = size(X);N=2 ;Ts=1 ; t=1:64*64/2 ; %% 能量拉伸矩阵G的比例因子gP1 = sum(sum(X.*X))/(64*64*block_num);P = P1 * block_num;lamda = mean((X.*X)');lamda = lamda';g = sqrt(P/sum(sqrt(lamda)))./sqrt(sqrt(lamda));%% 白化H = hadamard(block_num)/8;C = H*diag(g);ytx = C*X;%% 物理层%***************By Lin***************im=i;%单位虚部fc=5;            c1=cos(2*pi*fc*t);c2=sin(2*pi*fc*t);%***************By Lin***************%% I，Q两路d2=[0:2:t(end)-1];for i = 1:block_num    yI=reshape(ytx(i,:),2,64*64/2);  %提取一行 以两个符号为一组，抽取I，Q    pI=yI(1,:);    pQ=yI(2,:);    s1=pI.*c1 ; %I路调制cos    s2=pQ.*c2 ; %Q路调制sin    %s=s1-s2 ; %进入信道的信号s=s1-s2        %***************By Lin***************    s=s1+s2*im;%IQ两路复数叠加运算    %***************By Lin***************        ys(i,:) = s;end%% 行OFDM 不需要16-QAM调制和FECfor u=1:N:block_num    for j = 1:length(ys)        ifft_code(u:u+N-1,j)=ifft(ys(u:u+N-1,j))*100;    endend%% 信道传输snr=30;noise_pow = P1 * 10^(-snr/10);%noisy = sqrt(noise_pow)*randn(64,blockNum/2);noisy = zeros(block_num,64*64/2);ynoisy = ifft_code + noisy;%% fft变换for u=1:N:block_num    for j = 1:length(ifft_code)        fft_code(u:u+N-1,j)=fft(ynoisy(u:u+N-1,j))*1/100;    endend%% Decoder 接收端%先解调%y1=fft_code.*c1;%y2=fft_code.*(-c2);%***************By Lin***************y1=fft_code./c1;%与调制过程相反，对应除法y2=fft_code./(c2*im);%y2=real(y2);%取实部%***************By Lin***************%解调后从时域积分（求和）判决y1sum=0;y2sum=0;for j = 1:block_num    for i=1:64*64/2       y1sum(j,i)=sum(y1(j,(i-1)+1:i));       y2sum(j,i)=sum(y2(j,(i-1)+1:i));               %合并I，Q两路        k=2*i;        B(j,k-1)=y1sum(j,i);        B(j,k)=y2sum(j,i);    endendyrx = B;%% Decoder%diag(lambda) 得到之前x的协方差矩阵%yrx = ynoisy;sigma = mean((noisy.*noisy)'); %协方差矩阵的对角元素sigma = sigma';noise_pow = diag(noise_pow*ones(block_num,1));z = diag(lamda)*C'*inv(C*diag(lamda)*C'+ noise_pow)*yrx;%z = inv(C)*yrx;  %高SNR条件下 近似%% y_dct = zeros(height, width, frame_num);p_block = 1;for ff = 1:frame_num    for ii = 1:bh         for jj = 1:bw            if (bitmap(ii,jj,ff)==1)                y_dct(1+(ii-1)*64:ii*64,1+(jj-1)*64:jj*64,ff) = reshape(z(p_block,:),64,64);                p_block = p_block+1;            end        end    endendresult = idct3(y_dct);%% 量化----------------------------%for ii = 1:height    for jj = 1:width        for ff = 1:frame_num            if result(ii,jj,ff)>255                result(ii,jj,ff) = 255;            elseif result(ii,jj,ff)<0                result(ii,jj,ff) = 0;            else                 result(ii,jj,ff) = round(result(ii,jj,ff));            end        end    endendresult = real(result);imshow(uint8(result(:,:,1)));